//TWO SUM
vector<int>twoSum(vector<int>&nums, int target){
  int n=nums.size();
  int l=0, r=n-1;
  sort(nums.begin(),nums.end());
  int sum;
  while(l<r){
    sum=nums[l]+nums[r];
    if(sum==target) return {l,r};
    else if(sum<target) l++;
    else r++;
  }
  return {l,r};
}

//BEST TIME TO BUY AND SELL STOCKS
int maxProfit(vector<int>& prices) {
    int mint=prices[0];
    int prof=0;
    for(int i=1;i<prices.size();i++){
        int cost=prices[i]-mint;
        prof=max(prof,cost);
        mint=min(mint,prices[i]);
      }
        return prof;
    }

//MAX SUBARRAY
int maxSubArray(vector<int>& nums) {
        int sum=0;
        int maxi=INT_MIN;
        for(auto it:nums){
            sum+=it;
            maxi=max(maxi,sum);
            if(sum<0) sum=0;
        }
        return maxi;
    }

//3SUM
vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int n = nums.size();

        for (int i = 0; i < n; i++) {
            if (i && nums[i] == nums[i-1]) continue;
            int j = i+1, k = n-1;

            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    res.push_back({nums[i], nums[j++], nums[k--]});
                    while (j < k && nums[j] == nums[j-1]) j++;
                    while (j < k && nums[k] == nums[k+1]) k--;
                } 
                else if (sum < 0) j++;
                else k--;
            }
        }
        return res;
    }

//CONTAINING MOST WATER
int maxArea(vector<int>& height) {
        int n=height.size();
        int left=0;
        int right=n-1;
        int maxArea=0;
        while(left<right){
            int currArea=min(height[left],height[right])*(right-left);
            maxArea=max(currArea,maxArea);

            if(height[left]<height[right]) left++;
            else right--;
        }
        return maxArea;
}

//ROTATE IMAGE
void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        for(int i=0;i<n;i++){
            reverse(matrix[i].begin(),matrix[i].end());
      }
}

//LONGEST PALINDROMIC SUBSTRING
string longestPalindrome(string s) {
        int n = s.size(), start = 0, maxLen = 1;
        vector<vector<bool>> dp(n, vector<bool>(n, false));

        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
            for (int j = 0; j < i; j++) {
                if (s[i] == s[j] && (i - j < 3 || dp[j+1][i-1])) {
                    dp[j][i] = true;
                    if (i - j + 1 > maxLen) {
                        maxLen = i - j + 1;
                        start = j;
                    }
                }
            }
        }
        return s.substr(start, maxLen);
}

//VALID ANAGRAM
bool isAnagram(string s, string t) {
    if (s.length() != t.length()) return false;
    vector<int> freq(26, 0);

    for (int i = 0; i < s.size(); i++) {
        freq[s[i] - 'a']++;
        freq[t[i] - 'a']--; 
      }
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) return false;
      }
    return true; 
}

//SEARCH IN ROTATED ARRAY
int search(vector<int>& nums, int target) {
        int low = 0, high = nums.size() - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (nums[mid] == target) return mid;

            if (nums[low] <= nums[mid]) { // left part sorted
                if (nums[low] <= target && target < nums[mid]) high = mid - 1;
                else low = mid + 1;
            } else { // right part sorted
                if (nums[mid] < target && target <= nums[high]) low = mid + 1;
                else high = mid - 1;
            }
        }
        return -1;
}

//FIRST AND LAST POSITION IN ARRAY
 vector<int> searchRange(vector<int>& nums, int target) {
        int start = -1, end = -1;
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(nums[i] == target){
                start = i;
                break;
            }
        }
        for(int i=n-1; i>=0; i--){
            if(nums[i] == target){
                end = i;
                break;
            }
        }
        return {start, end};
}

//Kth LARGEST ELEMENT
int findKthLargest(vector<int>& nums, int k) {

        int mini=*min_element(nums.begin(),nums.end());
        int maxi=*max_element(nums.begin(),nums.end());

        vector<int>count(maxi-mini+1,0);
        for(int n:nums) count[n-mini]++;

        int rem=k;
        for(int i=count.size()-1;i>=0;i--){
            rem=rem-count[i];
            if(rem<=0) return i+mini;
        }
        return -1;
}

//SORT COLORS
void sortColors(vector<int>& nums) {
    while(!is_sorted(nums.begin(),nums.end())){
      for(int i=0;i<nums.size()-1;i++){
        if(nums[i]>nums[i+1])
          swap(nums[i],nums[i+1]);
    }
  }
}

//MERGE INTERVALS
vector<vector<int>> merge(vector<vector<int>>& arr) {
        int n=arr.size();
        sort(arr.begin(),arr.end());
        vector<vector<int>>ans;
        for(int i=0;i<n;i++){
            if(ans.empty() || arr[i][0]>ans.back()[1])
                ans.push_back(arr[i]);
            else ans.back()[1]=max(ans.back()[1],arr[i][1]);
        }
        return ans;
}

//REVERSE LINKEDLIST
ListNode* reverseList(ListNode* head) {
       ListNode* curr=head;
       ListNode* prev=NULL;

       while(curr!=NULL){
        ListNode* temp=curr->next;
        curr->next=prev;
        prev=curr;
        curr=temp;
       }
       return prev;
}

//MERGE TOW SORTED LISTS
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==NULL || list2==NULL) return list1==NULL ? list2 : list1;

        if(list1->val<=list2->val){
            list1->next=mergeTwoLists(list1->next,list2);
            return list1;
        }
        if(list1->val>=list2->val){
            list2->next=mergeTwoLists(list1,list2->next);
            return list2;
        }
        return NULL;
}

//LINKEDLIST CYCLE
 bool hasCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;

        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true; 
            }
        }
        return false; 
}

//INTERSECTION OF TWO LL
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL || headB==NULL) return NULL;
        ListNode* temp1=headA;
        ListNode* temp2=headB;
        while(temp1!=temp2){
            temp1=temp1->next;
            temp2=temp2->next;

            if(temp1==temp2) return temp1;

            if(temp1==NULL) temp1=headB;
            if(temp2==NULL) temp2=headA;
        }
        return temp1;
}

//VALID PARENTHESIS
bool isValid(string s) {
        unordered_map<char, char> map = {
            {')', '('},
            {'}', '{'},
            {']', '['}
        };
        stack<char> st;

        for (char c : s) {
            if (map.count(c)) {
                if (st.empty() || st.top() != map[c]) {
                    return false;
                }
                st.pop();
            } else {
                st.push(c);
            }
        }
        return st.empty();
}

//MIN STACK
class MinStack {
    stack<int> stack;
    stack<int> min;
public:
    MinStack() {
        min.push(INT_MAX);
    }
    
    void push(int val) {
        if(val<=min.top()) min.push(val);
        stack.push(val);
    }

    
    void pop() {
        if(stack.top()==min.top()) min.pop();
        stack.pop();
    }
    
    int top() {
        return stack.top();
    }
    
    int getMin() {
        return min.top();
    }
};

//QUEUE USING STACK

class MyQueue {
private:
    stack<int> s1;
    stack<int> s2;

public:
    MyQueue() {}

    void push(int x) {
        while (!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
        s1.push(x);
        while (!s2.empty()) {
            s1.push(s2.top());
            s2.pop();
        }
    }

    int pop() {
        int temp = s1.top();
        s1.pop();
        return temp;
    }

    int peek() {
        return s1.top();
    }

    bool empty() {
        return s1.empty();
    }
};

//MAX SLIDING WINDOW
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> ans;
        deque<int> dq;
        for (int i = 0; i < n; i++) {
            if (!dq.empty() && dq.front() == i - k) {
                dq.pop_front();
            }
            
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            if (i >= k - 1) {
                ans.push_back(nums[dq.front()]);
            }
        }
        
        return ans;
}

//NEXT GREATER ELEMENT 1
vector<int> nextGreaterElement(vector<int>& a, vector<int>& b) {
        map<int,int>mpp;
        vector<int>v;
        for(int i=0;i<b.size();i++){
            mpp[b[i]]=i+1;
        }
        for(int i=0;i<a.size();i++){
            int num=-1;
            if(mpp[a[i]])
            for(int j=mpp[a[i]];j<b.size();j++){
                if(b[j]>a[i]){
                    num=b[j];
                    break;
                }
            }
                v.push_back(num);
                }
                return v;
}

//NEXT GREATER ELEMENT 2
vector<int> nextGreaterElements(vector<int>& nums) {
        int n=nums.size();
        vector<int>nge;
        stack<int>st;
        for(int i=2*n-1;i>=0;i--){
            while(!st.empty() && st.top()<=nums[i%n]) st.pop();
            if(i<n){
                if(st.empty()) nge.push_back(-1);
                else nge.push_back(st.top());
            }
            st.push(nums[i%n]);
        }
        reverse(nge.begin(),nge.end());
        return nge;
}

//LONGEST SUBSTRING WITHOUT REPEATING CHARACTERS
int lengthOfLongestSubstring(string s) {
        if(s.size()==0) return 0;
        unordered_map<char,int>mpp;
        int i=0,j=0,ans=INT_MIN;
        while(j<s.size()){
            mpp[s[j]]++;
            if(mpp.size()==j-i+1) ans=max(ans,j-i+1);
            else if(mpp.size()<j-i+1){
                while(mpp.size()<j-i+1){
                    mpp[s[i]]--;
                    if(mpp[s[i]]==0) mpp.erase(s[i]);
                    i++;
                }
            }
            j++;
        }
        return ans;
}

//GROUP ANAGRAMS
vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>>mpp;
        for(auto x: strs){
            string word=x;
            sort(word.begin(),word.end());
            mpp[word].push_back(x);
        }
        vector<vector<string>>ans;
        for(auto x: mpp) ans.push_back(x.second);
        return ans;
}

//SUBARRAY SUM EQUALS K 
int subarraySum(vector<int>& nums, int k) {
        int n=nums.size();
        int preSum=0,cnt=0;
        map<int,int>mpp;
        mpp[0]=1;
        for(int i=0;i<n;i++){
            preSum+=nums[i];
            int remove=preSum-k;
            cnt+=mpp[remove];
            mpp[preSum]+=1;
        }
        return cnt;
}

//TOP K FREQUENT ELEMENTS
vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> seen;
        vector<int> arr;
        for(int i =0;i<nums.size();i++){
            seen[nums[i]]++;
        }
        for(int i=0;i<k;i++){
            int max1 = -1;
            int ele1 = -1;
            for(auto it = seen.begin() ; it != seen.end() ;it++){
                if(it->second > max1){
                    max1 = it->second;
                    ele1 = it->first;
                }
            }
            arr.push_back(ele1);
            seen.erase(ele1);
        }
        return arr;
}

//BINARY TREE INORDER TRAVERSAL
vector<int>inorder(Node* head){
    vector<int>res;
    helper(root,res);
    return res;
  }
void helper(Node* root, vector<int>&res){
   if(root!=NULL){
    helper(root->left, res);
    res.push_back(root->val);
    helper(root->right,res);
    }
}

//DIAMETER OF BINARY TREE
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int diameter=0;
        findmax(root,diameter);
        return diameter;
    }
private:
    int findmax(TreeNode* root, int &maxi){
        if(root==NULL) return 0;
        int l=findmax(root->left,maxi);
        int r=findmax(root->right,maxi);
        maxi=max(maxi,l+r);
        return 1+max(l,r);
    }

//LOWEST COMMON ANCESTOR OF BST
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL) return NULL;
        int curr=root->val;
        if(curr<p->val && curr<q->val){return lowestCommonAncestor(root->right,p,q);}
            
        if(curr>p->val && curr>q->val)
            {return lowestCommonAncestor(root->left,p,q);}
        return root;
}

//VALIDATE BST
void inorder(TreeNode *root,vector<int> &v)
  { 
    if(root==NULL) return ;
        inorder(root->left,v);
        v.push_back(root->val);
        inorder(root->right,v);
  }
    bool isValidBST(TreeNode* root) {
        vector<int> v;
        inorder(root,v);
        for(int i=1;i<v.size();i++){
            if(v[i] <= v[i-1]){
                return false;
                break;
            }
        }
        return true;
}

//KTH LARGEST ELEMENT
int findKthLargest(vector<int>& nums, int k) {
        int mini=*min_element(nums.begin(),nums.end());
        int maxi=*max_element(nums.begin(),nums.end());

        vector<int>count(maxi-mini+1,0);
        for(int n:nums) count[n-mini]++;

        int rem=k;
        for(int i=count.size()-1;i>=0;i--){
            rem=rem-count[i];
            if(rem<=0) return i+mini;
        }
        return -1;
}

//MERGE K LISTS
ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<int,vector<int>,greater<>>pq;
        int n=lists.size();
        for(int i=0;i<n;i++){
            while(lists[i]!=NULL){
                pq.push(lists[i]->val);
                lists[i]=lists[i]->next;
            }
        }
        ListNode *current = new ListNode(0);
        ListNode *dummy = current;
        while(!pq.empty()){
            current->next=new ListNode(pq.top());
            pq.pop();
            current=current->next;
        }
        return dummy->next;
}

//MEDIAN FROM DATA STREAM
priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    MedianFinder() {
    }
    void addNum(int num) {
        maxHeap.push(num);
        minHeap.push(maxHeap.top());
        maxHeap.pop();
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        return (maxHeap.top() + minHeap.top()) / 2.0;
}

//NUMBER OF ISLANDS
public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int num=0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(grid[i][j]=='1'){
                    num++;
                    dfs(grid,i,j);
                }
            }
        }
        return num;
    }
private:
    void dfs(vector<vector<char>>&grid, int i, int j){
        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || grid[i][j]!='1') return ;

        grid[i][j]='0';

        dfs(grid,i+1,j);
        dfs(grid,i-1,j);
        dfs(grid,i,j+1);
        dfs(grid,i,j-1);
  }

//COURSE SCHEDULE
bool canFinish(int n, vector<vector<int>>& prerequisites) {
        vector<int> adj[n];
        vector<int> indegree(n, 0);
        vector<int> ans;

        for(auto x: prerequisites){
            adj[x[0]].push_back(x[1]);
            indegree[x[1]]++;
        }

        queue<int> q;
        for(int i = 0; i < n; i++){
            if(indegree[i] == 0){
                q.push(i);
            }
        }

        while(!q.empty()){
            auto t = q.front();
            ans.push_back(t);
            q.pop();

            for(auto x: adj[t]){
                indegree[x]--;
                if(indegree[x] == 0){
                    q.push(x);
                }
            }
        }
        return ans.size() == n;
}

//CLONE GRAPH
unordered_map<Node*, Node*> mp;
    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;
        mp[node] = new Node(node->val);
        queue<Node*> q{{node}};
        while (!q.empty()) {
            Node* curr = q.front(); q.pop();
            for (auto adj: curr->neighbors) {
                if (!mp.count(adj)) {
                    mp[adj] = new Node(adj->val);
                    q.push(adj);
                }
                mp[curr]->neighbors.push_back(mp[adj]);
            }
        }
        return mp[node];
    }

//SHORTEST PATH IN BINARY MATRIX
vector<pair<int,int>> direction = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1,1}};
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        if(grid[0][0] == 1 or grid[m-1][n-1] == 1) return -1;
        grid[0][0] = 1;
        queue<pair<int,int>> q;
        q.push({0,0});
        while(!q.empty()){
            auto [x, y] = q.front();
            q.pop();
            if(x == m-1 and y == n-1) return grid[x][y];
            for(auto [x1, y1] : direction){
                int newX = x + x1;
                int newY = y + y1;
                if(newX >= 0 and newX < m and newY >= 0 and newY < n and grid[newX][newY] == 0){
                    grid[newX][newY] = grid[x][y]+1;
                    q.push({newX, newY});
                }
            }
        }
        return -1;
}

//CLIMBING STAIRS
int climbStairs(int n) {
    vector<int>dp(n+1,0);
    dp[1]=1;
    dp[0]=1;
    for(int i=2;i<=n;i++){
        dp[i]=dp[i-1]+dp[i-2];
    }
    return dp[n];
}

//HOUSE ROBBER
int rob(vector<int>& nums) {
        int n=nums.size();
        int prev=nums[0];
        int prev2=0;
        for(int i=1;i<n;i++){
            int take=nums[i];
            if(i>1) take+=prev2;
            int nottake=prev;
            int curr=max(take,nottake);
            prev2=prev;
            prev=curr;
        }
        return prev;
}

//COIN CHANGE
int coinChange(vector<int>& coins, int n) {
        int dp[++n];
        dp[0] = 0;
        sort(begin(coins), end(coins));
        for (int i = 1; i < n; i++) {
            dp[i] = INT_MAX;
            for (int c: coins) {
                if (i - c < 0) break;
                if (dp[i - c] != INT_MAX) dp[i] = min(dp[i], 1 + dp[i - c]);
            }
        }
        return dp[--n] == INT_MAX ? -1 : dp[n];
}

//LONGEST INCREASING SUBSEQUENCE
int f(int ind, int prev, vector<int>& arr, int n,vector<vector<int>>&dp){
    if(ind==n) return 0;
    if(dp[ind][prev+1]!=-1) return dp[ind][prev+1];
    int len=f(ind+1,prev,arr,n,dp);
    if(prev==-1 || arr[ind]>arr[prev]){
      len=max(len,1+f(ind+1,ind,arr,n,dp));
    }
    return dp[ind][prev+1]=len;
}
int lengthOfLIS(vector<int>& nums) {
    int n=nums.size();
    vector<vector<int>>dp(n,vector<int>(n+1,-1));
    return f(0,-1,nums,n,dp);
}

//LONGEST COMMON SUBSEQUENCE
int longestCommonSubsequence(string t1, string t2) {
        int m = t1.size(), n = t2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (t1[i - 1] == t2[j - 1]) 
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                else 
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m][n];
}

//EDIT DISTANCE
int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size(), pre;
        vector<int> cur(n + 1, 0);
        for (int j = 1; j <= n; j++) {
            cur[j] = j;
        }
        for (int i = 1; i <= m; i++) {
            pre = cur[0];
            cur[0] = i;
            for (int j = 1; j <= n; j++) {
                int temp = cur[j];
                if (word1[i - 1] == word2[j - 1]) {
                    cur[j] = pre;
                } else {
                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;
                }
                pre = temp;
            }
        }
        return cur[n];
}

//UNIQUE PATHS
int uniquePaths(int m, int n) {
        int i = 0, int j = 0;
        int minE=min(m,n);
        int totalSteps=m+n-2;
        long long paths=1;
        for(int i=1; i<minE; i++){
            paths=paths*(totalSteps-i+1)/i;
        }
        return (int)paths;
}

//SINGLE NUMBER
int singleNumber(vector<int>& nums) {
        int ans=nums[0];
        for(int i=1;i<nums.size();i++){
           ans ^=nums[i];
        }
        return ans;
}

//NUMBER OF 1 BITS
int hammingWeight(int n) {
        int cnt=0;
        for(int i=31;i>=0;i--){
            int ith_bit=(n>>i)&1;
            if(ith_bit>0) cnt++;
        }
        return cnt;
}

//COUNTING BITS
vector<int> countBits(int n) {
        vector<int>dp(n+1,0);
        int sub=1;
        for(int i=1;i<=n;i++){
            if(sub*2==i) sub=i;

            dp[i]=dp[i-sub]+1;
        }
        return dp;
}

//SUBSETS
vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>>result;
        int n=nums.size();
        for(int i=0;i<(1<<n);i++){
            vector<int>sub;
            for(int j=0;j<n;j++){
                if((i&(1<<j))>0) sub.push_back(nums[j]);
            }
            result.push_back(sub);
        }
        return result;
}



































