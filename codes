//TWO SUM
vector<int>twoSum(vector<int>&nums, int target){
  int n=nums.size();
  int l=0, r=n-1;
  sort(nums.begin(),nums.end());
  int sum;
  while(l<r){
    sum=nums[l]+nums[r];
    if(sum==target) return {l,r};
    else if(sum<target) l++;
    else r++;
  }
  return {l,r};
}

//BEST TIME TO BUY AND SELL STOCKS
int maxProfit(vector<int>& prices) {
    int mint=prices[0];
    int prof=0;
    for(int i=1;i<prices.size();i++){
        int cost=prices[i]-mint;
        prof=max(prof,cost);
        mint=min(mint,prices[i]);
      }
        return prof;
    }

//MAX SUBARRAY
int maxSubArray(vector<int>& nums) {
        int sum=0;
        int maxi=INT_MIN;
        for(auto it:nums){
            sum+=it;
            maxi=max(maxi,sum);
            if(sum<0) sum=0;
        }
        return maxi;
    }

//3SUM
vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int n = nums.size();

        for (int i = 0; i < n; i++) {
            if (i && nums[i] == nums[i-1]) continue;
            int j = i+1, k = n-1;

            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    res.push_back({nums[i], nums[j++], nums[k--]});
                    while (j < k && nums[j] == nums[j-1]) j++;
                    while (j < k && nums[k] == nums[k+1]) k--;
                } 
                else if (sum < 0) j++;
                else k--;
            }
        }
        return res;
    }

//CONTAINING MOST WATER
int maxArea(vector<int>& height) {
        int n=height.size();
        int left=0;
        int right=n-1;
        int maxArea=0;
        while(left<right){
            int currArea=min(height[left],height[right])*(right-left);
            maxArea=max(currArea,maxArea);

            if(height[left]<height[right]) left++;
            else right--;
        }
        return maxArea;
}

//ROTATE IMAGE
void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        for(int i=0;i<n;i++){
            reverse(matrix[i].begin(),matrix[i].end());
      }
}

//LONGEST PALINDROMIC SUBSTRING
string longestPalindrome(string s) {
        int n = s.size(), start = 0, maxLen = 1;
        vector<vector<bool>> dp(n, vector<bool>(n, false));

        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
            for (int j = 0; j < i; j++) {
                if (s[i] == s[j] && (i - j < 3 || dp[j+1][i-1])) {
                    dp[j][i] = true;
                    if (i - j + 1 > maxLen) {
                        maxLen = i - j + 1;
                        start = j;
                    }
                }
            }
        }
        return s.substr(start, maxLen);
}

//VALID ANAGRAM
bool isAnagram(string s, string t) {
    if (s.length() != t.length()) return false;
    vector<int> freq(26, 0);

    for (int i = 0; i < s.size(); i++) {
        freq[s[i] - 'a']++;
        freq[t[i] - 'a']--; 
      }
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) return false;
      }
    return true; 
}

//SEARCH IN ROTATED ARRAY
int search(vector<int>& nums, int target) {
        int low = 0, high = nums.size() - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (nums[mid] == target) return mid;

            if (nums[low] <= nums[mid]) { // left part sorted
                if (nums[low] <= target && target < nums[mid]) high = mid - 1;
                else low = mid + 1;
            } else { // right part sorted
                if (nums[mid] < target && target <= nums[high]) low = mid + 1;
                else high = mid - 1;
            }
        }
        return -1;
}

//FIRST AND LAST POSITION IN ARRAY
 vector<int> searchRange(vector<int>& nums, int target) {
        int start = -1, end = -1;
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(nums[i] == target){
                start = i;
                break;
            }
        }
        for(int i=n-1; i>=0; i--){
            if(nums[i] == target){
                end = i;
                break;
            }
        }
        return {start, end};
}

//Kth LARGEST ELEMENT
int findKthLargest(vector<int>& nums, int k) {

        int mini=*min_element(nums.begin(),nums.end());
        int maxi=*max_element(nums.begin(),nums.end());

        vector<int>count(maxi-mini+1,0);
        for(int n:nums) count[n-mini]++;

        int rem=k;
        for(int i=count.size()-1;i>=0;i--){
            rem=rem-count[i];
            if(rem<=0) return i+mini;
        }
        return -1;
}

//SORT COLORS
void sortColors(vector<int>& nums) {
    while(!is_sorted(nums.begin(),nums.end())){
      for(int i=0;i<nums.size()-1;i++){
        if(nums[i]>nums[i+1])
          swap(nums[i],nums[i+1]);
    }
  }
}

//MERGE INTERVALS
vector<vector<int>> merge(vector<vector<int>>& arr) {
        int n=arr.size();
        sort(arr.begin(),arr.end());
        vector<vector<int>>ans;
        for(int i=0;i<n;i++){
            if(ans.empty() || arr[i][0]>ans.back()[1])
                ans.push_back(arr[i]);
            else ans.back()[1]=max(ans.back()[1],arr[i][1]);
        }
        return ans;
}

//REVERSE LINKEDLIST
ListNode* reverseList(ListNode* head) {
       ListNode* curr=head;
       ListNode* prev=NULL;

       while(curr!=NULL){
        ListNode* temp=curr->next;
        curr->next=prev;
        prev=curr;
        curr=temp;
       }
       return prev;
}

//MERGE TOW SORTED LISTS
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==NULL || list2==NULL) return list1==NULL ? list2 : list1;

        if(list1->val<=list2->val){
            list1->next=mergeTwoLists(list1->next,list2);
            return list1;
        }
        if(list1->val>=list2->val){
            list2->next=mergeTwoLists(list1,list2->next);
            return list2;
        }
        return NULL;
}

//LINKEDLIST CYCLE
 bool hasCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;

        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true; 
            }
        }
        return false; 
}

//INTERSECTION OF TWO LL
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL || headB==NULL) return NULL;
        ListNode* temp1=headA;
        ListNode* temp2=headB;
        while(temp1!=temp2){
            temp1=temp1->next;
            temp2=temp2->next;

            if(temp1==temp2) return temp1;

            if(temp1==NULL) temp1=headB;
            if(temp2==NULL) temp2=headA;
        }
        return temp1;
}

//





